# Style guide C++

## 1. Файлы

- Имя файла = имя основного класса (CamelCase): `MyActor.h`.
- Один публичный класс UE — в одном заголовке.
- Утилитарные файлы без UE-классов допускают `snake_case`.
- Обязательно английский язык.

---

## 2. Форматирование

- Отступ — **табуляция**.
- Лимит строки — **120 символов**.
- Скобки на своей строке:

```cpp
while ( bOk )
{
	if ( 0 ) 
	{
		…
	} 
}
```

- Фигурные скобки обязательны у `if`, `for`, `while`.
- Один пробел после ключевых слов, вокруг скобок и операторов:
```cpp
if ( bOk && ( A < B ) )
{
	// ...
}

currentHealth = FMath::Clamp( currentHealth - amount, 0.f, maxHealth );
```
- Исключение:
Для UE-макросов пробел перед скобками **не ставим**.
```cpp
 UFUNCTION(BlueprintCallable, Category="Health")
 UCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))
 UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Health")
```
и т.п.
- Пустые строки:
  - между логическими блоками внутри функции;
  - между методами.
- Имена указателей/ссылок:

```cpp
int32* Ptr;
```

---

## 3. Наименование

### Пользовательские типы

Любые классы, структуры, интерфейсы: **CamelCase** с соответствующим префиксом.

| Тип            | Префикс | Пример                |
|----------------|---------|-----------------------|
| Actor          | A       | `AEnemyCharacter`     |
| UObject        | U       | `UInventoryComponent` |
| Struct         | F       | `FWeaponData`         |
| Slate Widget   | S       | `SMainMenuWidget`     |
| Template контейнер | T   | `TArray<int32>`       |

### Переменные

- Локальные: `lowerCamelCase`
- Параметры функций: `lowerCamelCase`
- Поля `public`: `CamelCase` — `Health`
- Поля `protected`: `CamelCase_` — `Health_`
- Поля `private`: `CamelCase_` — `Health_`
- Булевые: `bIsDead`
- Константы: `cMaxSpeed`

### Функции и методы

- Функции: `CamelCase`
- Методы: `CamelCase`
- Методы `bool` начинать с вопросительного глагола:
  - `Is`, `Can`, `Has`, `Should`

---

## 4. Качество и безопасность

- Избегать магических чисел.
- Короткие функции: до ~50 строк (рекомендация).
- Максимум один уровень вложенности там, где можно.
- **Единственная ответственность класса**  
  Один класс — одна чёткая ответственность (Single Responsibility Principle).  
  Лишнюю функциональность выносить:
  - в отдельные компоненты (`U…Component`),
  - в отдельные сервисы/менеджеры.
- **Единственная ответственность функции**  
  Функция выполняет строго 1 задачу.  
  Лишнюю функциональность выносить в другие функции.
- Везде, где можно — `const` и `const&`.

### override / final

- Все переопределяемые `virtual`-методы — с `override`.
- `final` для закрываемых классов и методов.

### auto

- `auto` — только без потери читаемости (если понятно, какой это тип).

### Сборщик мусора и указатели

- `UPROPERTY()` для всех полей-указателей.
- Лучше использовать умные указатели: `TUniquePtr`, `TSharedPtr`, `TWeakPtr`.
- Избегать `new` / `delete`.

Пример:

```cpp
UPROPERTY()
TUniquePtr<AEntity> Enemy;
```

- При работе с ресурсами лучше использовать RAII.
- Проверять указатели / `ensure` / `check` по ситуации.

При использовании сырых указателей **без** сборщика мусора:

- либо гарантировать их валидность логикой и `check`,
- либо проверять на `nullptr` и безопасно обрабатывать ошибку.

Для UE-указателей:

- Использовать `IsValid()` для `UObject` / `AActor`, если есть риск, что объект уже уничтожен.

### Правила для `#include`

В `.cpp` файлах порядок:

1. Заголовок своего класса.
2. Заголовки проекта.
3. C++ Standard Library.
4. UE Engine Headers.

В `.h` файлах:

- `#pragma once` в начале.
- Только действительно необходимые `#include`.
- Если не требуется полное определение класса — forward declaration:

```cpp
class UMyComponent;
class AEnemy;
```

- В `.h` с `UCLASS` / `USTRUCT` / `UENUM` обязательно:

```cpp
#include "MyClass.generated.h" // последним инклюдом
```

---

## 5. Комментарии
- Комментарии на английском 
- Для методов кратко объяснять назначение и возвращаемое значение.
- Для классов кратко объяснять назначение класса.  
- При необходимости можно указать инвариант класса.

Формат:

```cpp
// (Кто сделал)
// Комментарий (можно в несколько строк)
```

- Геттеры, сеттеры и функции в 1–2 строки, назначение которых очевидно, можно не комментировать.

---

## 6. Правила Pull Request

- Самое главное: добавлять в git только то, что ты **реально менял**, другой мусор не надо.
- `git add` только файл(ы), который ты менял.

### 6.1 Название ветки и PR

Формат веток:

- `feature/123-short-title/имя фамилия` (можно и просто имя)  
- `bugfix/124-fix-crash/имя фамилия` (можно и просто имя)
- `ci/...` по необходимости 
- `docs/...` по необходимости
- `refactor/...` по необходимости
- `content/...` по необходимости
- `balance/...` по необходимости

### 6.2 Описание PR (обязательно)

- На русском языке.

Пример структуры:

**Что:**

- Добавлен компонент `U…Component`
- Переделан расчёт урона с учётом расстояния

### 6.3 Описания коммитов

- Осмысленные описания коммитов:

```bash
git commit -m "add U…Component base class #123"
```

### 6.4 Перед созданием PR

Обязательно:

- Собрать проект.
- Убедиться, что всё работает.

### 6.5 Код-ревью

- Желательно без самослияния.
- После серьёзных изменений ещё раз попросить посмотреть.

---

## 7. Объявление класса

Порядок секций:

```cpp
class AMyActor : public AActor
{
public:
	// Public

protected:
	// Protected

private:
	// Private
};
```

- Сначала то, что важно пользователю класса, затем всё остальное.

## 8. Блупринты
- Все настраиваемые параметры должны быть в категории Settings:
```cpp
UPROPERTY( EditAnywhere, Category = "Settings" )
float SearchRadius_ = 15000.0f;
```
- Можно использовать подкатегории:
```cpp
UPROPERTY( EditAnywhere, Category = "Settings|AI" )
TObjectPtr<AActor> Target_;
```
- Параметры в компонентах обязательно помещать в подкатегорию с соответствующим названием:
  - В классе UUnitMovementComponent:
```cpp
UPROPERTY(EditAnywhere, Category = "Settings|Movement")
float SnapToGroundDistance = 100.0f;
```
- Это необходимо, потому что параметры компонента появляются в классе, в котором находится этот компонент.
